class Solution {
    public boolean isBipartite(int[][] graph) {
        // No triangle pattern.
        boolean[] marked = new boolean[graph.length];
        Set<Integer> sameLevel = null;
        Set<Integer> old = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        for ( int k = 0; k < graph.length; k++ ) {
            if ( graph[k].length != 0 && !marked[k] ) {
                queue.offer(k);
                marked[k] = true;
                while ( !queue.isEmpty() ) {
                    int size = queue.size();
                    sameLevel = old;
                    old = new HashSet<>();
                    for ( int i = 0; i < size; i++ ) {
                        int node = queue.poll();
                        for ( int j = 0; j < graph[node].length; j++ ) {
                            if ( sameLevel.contains(graph[node][j]) ) return false;
                            if ( marked[graph[node][j]] ) continue;
                            old.add(graph[node][j]);
                            queue.offer(graph[node][j]);
                            marked[graph[node][j]] = true;
                        }
                    }
                }
            }   
        }
        return true;
    }
}


                    // System.out.printf("size = %d\n", size);
                    // System.out.printf("sameLevel = ");
                    // for (int num : sameLevel) {
                    //         System.out.printf("%d, ", num);
                    //     }
                    // System.out.println("");
                    // System.out.printf("old = ");
                    // for (int num : old) {
                    //         System.out.printf("%d, ", num);
                    //     }
                    // System.out.println("");
